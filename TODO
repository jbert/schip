For 0.2:
========

- mad Parse::RecDescent errors, but only when running under 'make test'

- add macros

- allow writing primitives (e.g. 'not') in scheme

- implement 'when' as a macro transforming to 'if'

- implement 'let' as a macro transforming to 'lambda'
	- consider deparse (maybe we need to give up on deparse?)
	- or provide properties on forms, so defmacro can stash original code
	- and quote can add a marker for deparse


==================================================


- allow doc strings

- get error text out of parse.recdescent + report
	- decorate AST with line number (and col?)?
	- throw exception

- write/grab some more examples
	- project euler?
	- compare output undef 'schip' and 'mzscheme -f'
		- correctness (stdout) and start measuring performance :-)
		DONE - compare as autotest

- remove some commonality in the numeric ops with a base class
	- implement in terms of 'fold'? 

- add (more) tests for recursion and (define (foo x) )

- design perl/scheme interop
	- could make use of sigils to call out to perl vars
		- or do we want more equivalence?
	- need oo support in scheme?
		- rip off arc/clojure?

- cleanup horrible hack of scalar return from parser->parse. Old code wanted one 'tree',
	newer code needs to know it can get back a list of trees (for full-parse of source file).
	Fix: search for '$tree.*=.*->parse'

- add boolean type and type coercion
	- #t and #f parse to s.ast.bool
	- is a bool a number? (No, you don't want addition etc)
	- coerce arg to 'if' to boolean
	- (or just add is_true method to s.ast?)

- add more numeric tower (complex and exact)?

- can we get as far as compiling lambdas to perl code?
	- they could install into the environment in the same way that the
	initially supplied primitives do
